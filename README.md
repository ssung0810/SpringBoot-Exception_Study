## 들어가기에 앞서

서블릿이나 프레임워크의 도움이 없는 가장 기본적인 상태에서부터 에러를 경험하고 화면을 출력하는 방법부터 스프링부트를 이용해서 에러를 처리하고 화면을 만드는 것까지의 학습 프로젝트이다.

<br>

<br>

클라이언트가 서버에 요청을 보내면 기본적으로 아래와 같은 순서로 전달이 된다.

- WAS -> 필터 -> 서블릿 -> 인터셉터 -> 컨트롤러

<br>

에러가 발생하면 전달되는 순서는 순서의 반대로 돌아간다고 생각하면 된다.

- 컨트롤러 -> 인터셉터 -> 서블릿 -> 필터 -> WAS

<br>

컨트롤러에서 발생하는 에러가 타고타고 마지막에 WAS까지 도달한다.

<br>

<br>

시작전에 프로젝트를 스프링부트로 생성했기 때문에 스프링부트에서 기본적으로 제공해주는 에러페이지를 보여주지 않도록 설정해야한다.
application.properties에 server.error.whitelabel.enabled=false를 추가한다.

<br>

이제 내가 학습한 순서대로 글을 작성하고 그때그때 추가된 파일들의 이름들을 정리해서 적고자한다. 글을 보고 따라오고 싶으신분은 프로젝트를 받아서 나와 같은 순서로 학습하면 될것이다.

필자가 올린 프로젝트는 이미 완성상태이기 때문에 처음부터 따라오고싶으신분은 번호에서 사용한 파일들을 개인 프로젝트에 복사하거나 코드를 따라 치면서 학습하면 될것이다.

<br>

<br>

<br>

## 학습순서

### (1)

가장 먼저 에러가 발생 후 WAS까지 가는동안 try~catch등으로 에러를 잡지 못했을 때의 상황을 구현해 보았다.

<br>

WAS까지 도달한 에러는 서버에서 어떻게 해야할지에 대한 설정이 없기때문에 500에러를 반환하게 된다.

이 경우에는 어떤 에러가 터져도 결국은 서버가 할 수 있는 것이 없는 경우이기 때문에 500에러를 반환하게 된다.

<br>

> 추가된 파일 => ServletException

<br>

### (2)

서블릿에 response.sendError를 이용해서 에러상태코드와 메세지를 전달하는 방식을 구현해 보았다.

<br>

response.sendError를 이용하면 에러가 발생한것은 아니기 때문에 에러에 대한 대응을 하지는 것은 아니지만 서블릿 컨테이너에 어떤 상태코드를 리턴할지에 대한 내용을 담아 줄 수있었다.

예를 들어 response.sendError(404) 라고 코드를 작성한다면 이 페이지를 호출했을 때 404에러를 보여줄 수 있다.

에러가 발생했을 때 반드시 500에러를 발생시키는 경우와는 다르게 에러내용을 직접 지정할 수 있다.

<br>

> 추가된 파일 => ServletException 내부에 error404, error500 api 추가

<br>

### (3)

에러가 발생했을 때 WAS에서 기본적으로 보여주는 페이지는 너무 직접적이기에 보여줄 수 있는 페이지를 만들어보았다.

xml로 설정하는 방법도 있지만 스프링부트에서 제공하는 서블릿을 이용하는 방법으로 구현했다.

<br>

먼저 특정 에러가 발생했을 때 다시 호출할 컨트롤러를 지정해주었다. 404, 500 등 상태코드에 따라서 지정할 수도 있고 RuntimeException등 에러를 직접 지정할 수도 있다.

그리고 에러발생 시 다시 호출하는 컨트롤러와 화면에 보여줄 에러페이지를 만들었다.

<br>

>  추가된 파일 => WebServerCustomizer, 404.html, 500.html

<br>

### (4)

위의 내용들을 잠시 정리해보면 에러가 발생하거나 sendError로 에러의 내용을 넘겨주면 WAS에 도달했을 때 WAS는 에러에 대한 제어가 있는지 확인해해본다,

WAS가 확인하는 에러에 대한 제어내용이 WebServerCustomizer에서 작성한 내용이다.

WAS가 확인했을 때 특정 상태코드나 에러에 대해서 특정 컨트롤러를 호출하도록 되있다면 WAS는 다시 요청을 보낸다. 마치 처음 요청이 들어온것과 비슷하게 된다.

이렇게되면 사용자는 한번만 호출한것처럼 보이면서 에러페이지가 나타나지만 내부에서는 2번 호출된것과 같은 진행이 이루어진다.

이때 WAS는 해당 컨트롤러를 그냥 호출하는 것이 아니라 에러에 대한 내용들을 request의 attribute에 담아서 보내준다.

해당 내용은 RequestDispatcher에 상수로 저장되어있기 때문에 상수를 그대로 가져와서 사용하면 된다.

log를 이용해서 에러가 터졌을 때 특정 상수가 어떤 내용들을 반환하는지 확인해볼 수 있다.

그리고 DispatcherType이 어떤 값이 반환되었는지도 잘 살펴보자.

<br>

>  추가된 파일 => ErrorPageController내부에 상수와 상수를 출력하는 printErrorInfo메소드

<br>

### (5)

에러가 발생해서 다시 WAS부터 호출이 되면 필터와 인터셉터도 모두 다시 호출되게 된다. 그런데 필터와 인터셉터는 로그인 인증을 위해서 많이 사용하는 장소이다.

이미 해결된 기능을 중복해서 실행시키는 것은 비효율적이기 때문에 필요하지 않은경우에는 필터와 인터셉터를 거치지 않게 할 필요가 있다.

<br>

**서블릿**은 이런 상황을 위해서 DispatcherType을 지정한다.

클라이언트의 요청이 들어오면 값이 REQUEST, 에러로 인해 호출되면 ERROR의 값을 반환한다. 그 외에도 FORWARD, INCLUDE, ASYNC 등이 있다. Type에 대한 자세한 내용이 알고싶으신 분들은 찾아보기를 권장한다.

<br>

기본 설정으로는 REQUEST의 경우에만 필터를 호출하도록 되있지만 필요에 의해서 추가 설정도 할 수 있다.

WebConfig에서 setDispatcherTypes에 DispatcherType.ERROR를 추가하면 에러의 경우에도 필터를 호출한다.

setDispatcherTypes설정이 없다면 기본값으로 REQUEST의 경우에만 필터를 호출한다.

<br>

>  추가된 파일 => LogFilter, WebConfig

<br>

### (6)

필터의 경우는 5번과 같이 설정했을 때 에러페이지 호출 시 중복호출이 안되도록 설정할 수 있다. 이번에는 **인터셉터**를 설정해보자.

<br>

인터셉터는 필터처럼 DispatcherType을 보고 판단하는 방법이 없다.

대신 excludePathPatterns를 이용해서 인터셉터를 타지 않는 특정 경로를 입력할 수 있다.

지금 프로젝트에서는 error-page를 시작으로 URI를 만들고있기 때문에 "/error-page/**" 이렇게 설정하면 error-page와 그 하위에 있는 모든 경로는 인터셉터를 타지 않게 된다.

<br>

> 추가된 파일 => LogInterceptor, WebConfig내부에 addInterceptors메소드

<br>

### (7)

이제는 스프링부트가 제공해주는 기능들을 사용해보자.

이때까지의 방식은 만들고 관리해야하는 것들이 너무 많았다. 스프링부트는 기본적인 설정이 끝난채로 우리에게 기능을 제공하고있다.

<br>

스프링부트는 에러페이지를 자동으로 등록하는 역할로 ErrorMvcAutoConfiguration이라는 클래스가 있다.

이 클래스는 위에서 만든 WebServerCustomizer클래스의 역할을 하는 것이다. 스프링부트가 제공하는 클래스가 있지만 직접 클래스를 만들어서 설정을 하게되면 직접만든 클래스의 설정을 따른다.

그리고 에러페이지를 호출할 컨트롤러로 BasicErrorController가 기본적으로 등록이 되있다. 이 컨트롤러는 /error를 매핑해서 처리하도록 되어있다.
위에서 만든 ErrorPageController의 역할을 대신한다.

이렇게 스프링부트가 모든기능을 만들어서 제공하고 있기 때문에 개발자는 html파일만 만들어주면 자동으로 에러와 페이지를 매핑한다.
resource/templates/error안에 4xx, 404, 500, 5xx 등 에러코드에 맞는 이름으로 html을 만들어주면 된다.

에러페이지의 매핑은 더 구체적인것부터 덜 구체적인 순서로 매핑된다. (404 -> 4xx) 순서로 매핑된다.
매핑파일이 없으면 error.html을 찾게되고 이것도 없으면 static을 찾게된다.

<br>

> 추가된 파일 => templates/error/ 아래에 4xx.html, 404.html, 500.html || WebServerCustomizer내에서 @Component주석처리

<br>

### (8)

스프링부트는 에러페이지에 데이터를 넘길수있도록 해준다.
다음과 같은 데이터들을 model에 담아서 넘겨준다.

- timestamp
- status
- error
- exception
- trace
- message
- errors
- path 

자세한 내용이 궁금하신분은 찾아보기를 권장한다.

<br>

이렇게 전달된 데이터는 에러페이지 html에서 출력할 수 있다.

model에 담기는 내용중 exception, message, stack, errors는 출력되기에는 민감한 내요들이기 때문에 스프링부트에서 기본값으로 출력이 안되도록 설정되있다.
만약 출력을 원한다면 server.error.include-exception=true와 같이 원하는 내용을 설정해주어야 한다.

<br>

각 에러마다 설정방식과 이름이 조금씩 다르므로 코드를 참고하거나 인터넷에서 찾아보며 젹용하기를 권장한다.

<br>

> 추가된 파일 => 500.html파일 내용 변경(출력코드 추가)
